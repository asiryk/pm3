use std::error::Error;

use daemonize::Daemonize;

fn main() -> Result<(), Box<dyn Error>> {
    println!("daemon: init");

    Daemonize::new().start()?;

    // Build tokio runtime after daemonizing, otherwise it won't work
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap()
        .block_on(async {
            println!("daemon: starting server");
            rpc_server::start_rpc_server().await.unwrap();
        });

    Ok(())
}

mod rpc_server {
    use futures::{future, prelude::*};
    use pm3::rpc::Pm3;
    use std::error::Error;
    use std::net::{IpAddr, Ipv6Addr, SocketAddr};
    use tarpc::{
        context,
        server::{self, incoming::Incoming, Channel},
        tokio_serde::formats::Json,
    };

    #[derive(Clone)]
    pub struct Pm3Server(SocketAddr);

    #[tarpc::server]
    impl Pm3 for Pm3Server {
        async fn hello(self, _: context::Context, name: String) -> String {
            format!("Hello, {name}! You are connected from {}", self.0)
        }

        async fn ping(self, _: context::Context) {
            ()
        }

        async fn kill(self, _: context::Context) {
            println!("daemon: kill");
            std::process::exit(0);
        }
    }

    pub async fn start_rpc_server() -> Result<(), Box<dyn Error>> {
        let server_addr = SocketAddr::new(IpAddr::V6(Ipv6Addr::LOCALHOST), 9876);
        let transport = tarpc::serde_transport::tcp::listen(server_addr, Json::default);
        let mut listener = transport.await?;
        listener.config_mut().max_frame_length(usize::MAX);
        listener
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| {
                let server = Pm3Server(channel.transport().peer_addr().unwrap());
                channel.execute(server.serve())
            })
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
            .await;

        Ok(())
    }
}
